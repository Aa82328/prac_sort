# prac_sort
**Анализ алгоритма: Сортировка выбором (Selection Sort)**

---

**Определение:**
Сортировка выбором — это алгоритм сортировки, который на каждом шаге находит минимальный элемент в неотсортированной части массива и меняет его местами с первым элементом этой части. Таким образом, отсортированная часть массива постепенно увеличивается, а неотсортированная — уменьшается.

---

**Анализ:**
- Алгоритм делит массив на две части:
  - Отсортированная (в начале)
  - Неотсортированная (оставшаяся часть)
- На каждом шаге внешнего цикла:
  - Находится минимальный элемент в неотсортированной части
  - Этот элемент меняется местами с первым элементом неотсортированной части
- Внешний цикл выполняется n-1 раз (где n — количество элементов)
- Внутренний цикл выполняется n-1, n-2, ..., 1 раз за каждый проход
- Общее количество сравнений:
  (n-1) + (n-2) + ... + 1 = n(n-1)/2

---

**Временная сложность:**
- Лучший случай: O(n²)
- Средний случай: O(n²)
- Худший случай: O(n²)

---

**Объяснение временной сложности:**
Временная сложность O(n²) возникает из-за двух вложенных циклов:
- Внешний цикл выполняется n-1 раз
- Внутренний цикл в среднем выполняется около n/2 раз
- Общее количество операций пропорционально n²

---

**Результат работы в IDE:**

Исходный массив:
[64, 25, 12, 22, 11]

Отсортированный массив:
[11, 12, 22, 25, 64]

**Примечание:**
Алгоритм сортировки выбором прост в реализации, но неэффективен для больших массивов из-за квадратичной сложности. Он хорошо подходит для обучения и для небольших наборов данных.

---

**Анализ алгоритма: Сортировка обменом (Bubble Sort)**

---

**Определение:**
Сортировка обменом (пузырьковая сортировка) — это алгоритм сортировки, который многократно проходит по массиву, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке. Этот процесс повторяется до тех пор, пока массив не будет полностью отсортирован.

---

**Анализ:**
- Алгоритм последовательно сравнивает каждый элемент с соседним элементом
- Если текущий элемент больше следующего, происходит обмен местами
- После каждого полного прохода по массиву самый большой элемент "всплывает" в конец
- Внешний цикл контролирует количество проходов по массиву
- Внутренний цикл выполняет сравнение и обмен соседних элементов
- Количество проходов равно n-1, где n — количество элементов в массиве
- В каждом проходе количество сравнений уменьшается на 1

---

**Временная сложность:**
- Лучший случай: O(n) — когда массив уже отсортирован
- Средний случай: O(n²)
- Худший случай: O(n²) — когда массив отсортирован в обратном порядке

---

**Объяснение временной сложности:**
Временная сложность O(n²) возникает из-за двух вложенных циклов:
- Внешний цикл выполняется n-1 раз
- Внутренний цикл в худшем случае выполняется n-1, n-2, ..., 1 раз
- Общее количество сравнений: (n-1) + (n-2) + ... + 1 = n(n-1)/2
- Это приводит к квадратичной зависимости от размера массива

---

**Результат работы в IDE:**

Исходный массив:
64 34 25 12 22 11 90

Отсортированный массив:
11 12 22 25 34 64 90

---

**Примечание:**
Алгоритм пузырьковой сортировки прост для понимания и реализации, но неэффективен для больших массивов из-за квадратичной временной сложности. Основное преимущество — возможность раннего завершения, если массив уже отсортирован.

---
**Анализ алгоритма: Сортировка вставками (Insertion Sort)**

---

**Определение:**
Сортировка вставками — это алгоритм сортировки, который строит отсортированную часть массива постепенно, вставляя каждый новый элемент в правильную позицию внутри уже отсортированной части. Алгоритм обрабатывает элементы последовательно, начиная со второго элемента массива.

---

**Анализ:**
- Алгоритм делит массив на две части: отсортированную (слева) и неотсортированную (справа)
- Изначально первый элемент считается отсортированным
- На каждом шаге берется следующий элемент из неотсортированной части
- Элемент сравнивается с элементами в отсортированной части справа налево
- Все элементы, большие текущего, сдвигаются на одну позицию вправо
- Текущий элемент вставляется на найденную правильную позицию
- Процесс повторяется до тех пор, пока все элементы не будут отсортированы

---

**Временная сложность:**
- Лучший случай: O(n) — когда массив уже отсортирован
- Средний случай: O(n²)
- Худший случай: O(n²) — когда массив отсортирован в обратном порядке

---

**Объяснение временной сложности:**
Временная сложность O(n²) возникает из-за вложенных циклов:
- Внешний цикл выполняется n-1 раз (для элементов со 2 по последний)
- Внутренний цикл в худшем случае может выполняться i раз для i-го элемента
- Общее количество операций: 1 + 2 + 3 + ... + (n-1) = n(n-1)/2
- Это приводит к квадратичной зависимости от размера массива

---

**Результат работы в IDE:**

Исходный массив:
12 11 13 5 6

Отсортированный массив:
5 6 11 12 13

---

**Примечание:**
Сортировка вставками эффективна для небольших массивов и почти отсортированных данных. В лучшем случае (уже отсортированный массив) сложность линейная O(n). Алгоритм стабилен и работает "на месте", не требуя дополнительной памяти.

---
**Анализ алгоритма: Сортировка слиянием (Merge Sort)**

---

**Определение:**
Сортировка слиянием — это алгоритм сортировки, основанный на принципе "разделяй и властвуй". Алгоритм рекурсивно разделяет массив на две половины до тех пор, пока не останутся подмассивы длиной 1, затем объединяет отсортированные подмассивы в один отсортированный массив.

---

**Анализ:**
- Алгоритм использует стратегию "разделяй и властвуй"
- Массив рекурсивно делится пополам до базового случая (массив длиной 0 или 1)
- Базовый случай: массивы длиной 0 или 1 считаются уже отсортированными
- После разделения происходит слияние отсортированных половин
- Процесс слияния сравнивает элементы из двух подмассивов и объединяет их в один отсортированный массив
- Алгоритм требует дополнительной памяти для хранения временных подмассивов

---

**Временная сложность:**
- Лучший случай: O(n log n)
- Средний случай: O(n log n)
- Худший случай: O(n log n)

**Пространственная сложность:**
- O(n) — требуется дополнительная память для временных массивов

---

**Объяснение временной сложности:**
Временная сложность O(n log n) объясняется следующим:
- Рекурсивное деление массива: на каждом уровне рекурсии массив делится пополам, что дает log₂ n уровней
- На каждом уровне выполняется операция слияния с линейной сложностью O(n)
- Общая сложность: количество уровней × сложность слияния на каждом уровне = O(log n) × O(n) = O(n log n)
- Эта сложность сохраняется во всех случаях, так как деление и слияние выполняются независимо от исходного порядка элементов

---

**Результат работы в IDE:**

Исходный массив:
38 27 43 3 9 82 10

Отсортированный массив:
3 9 10 27 38 43 82

---

**Примечание:**
Сортировка слиянием является стабильным алгоритмом и гарантирует временную сложность O(n log n) во всех случаях. Основной недостаток — требование дополнительной памяти O(n), что делает его менее эффективным по памяти по сравнению с некоторыми другими алгоритмами сортировки.

---
**Анализ алгоритма: Сортировка Шелла (Shell Sort)**

---

**Определение:**
Сортировка Шелла — это алгоритм сортировки, который является модификацией сортировки вставками. Алгоритм сортирует элементы, находящиеся на определенном расстоянии друг от друга (шаге), постепенно уменьшая этот шаг до 1. Это позволяет элементам быстрее занимать свои правильные позиции.

---

**Анализ:**
- Алгоритм использует последовательность шагов (gap), начиная с большого значения и уменьшая его до 1
- На каждом шаге выполняется сортировка вставками для элементов, находящихся на расстоянии gap
- Большие шаги позволяют элементам перемещаться на большие расстояния, что ускоряет процесс
- По мере уменьшения шага массив становится более упорядоченным
- Когда шаг становится равным 1, выполняется обычная сортировка вставками
- Алгоритм работает "на месте", не требуя дополнительной памяти

---

**Временная сложность:**
- Лучший случай: O(n log n)
- Средний случай: зависит от выбранной последовательности шагов
- Худший случай: O(n²) — для некоторых последовательностей шагов

**Пространственная сложность:**
- O(1) — требуется только постоянная дополнительная память

---

**Объяснение временной сложности:**
Временная сложность сортировки Шелла зависит от выбранной последовательности шагов:
- При использовании последовательности Шелла (n/2, n/4, ..., 1) сложность составляет O(n²)
- При использовании последовательности Кнута (1, 4, 13, 40, ...) сложность составляет O(n^(3/2))
- При использовании последовательности Седжвика сложность может достигать O(n log² n)
- Эффективность достигается за счет того, что на больших шагах элементы перемещаются на значительные расстояния, а на малых шагах массив уже частично отсортирован

---

**Результат работы в IDE:**

Исходный массив:
12 34 54 2 3

Отсортированный массив:
2 3 12 34 54

---

**Примечание:**
Сортировка Шелла является улучшенной версией сортировки вставками и показывает хорошую производительность на практике, особенно для массивов среднего размера. Эффективность алгоритма сильно зависит от выбранной последовательности шагов.

---
**Анализ алгоритма: Быстрая сортировка (Quick Sort)**

---

**Определение:**
Быстрая сортировка — это алгоритм сортировки, основанный на стратегии "разделяй и властвуй". Алгоритм выбирает опорный элемент, разделяет массив на две части относительно этого элемента (элементы меньше опорного и элементы больше опорного), затем рекурсивно сортирует полученные части.

---

**Анализ:**
- Алгоритм использует стратегию "разделяй и властвуй"
- Выбирается опорный элемент (pivot) - обычно последний или случайный элемент
- Массив разделяется на три части:
  - Элементы меньше опорного
  - Опорный элемент
  - Элементы больше опорного
- Процесс разделения выполняется методом partition
- Рекурсивно применяется к левой и правой частям
- Базовый случай рекурсии: массив длиной 0 или 1 уже отсортирован

---

**Временная сложность:**
- Лучший случай: O(n log n) — когда опорный элемент делит массив пополам
- Средний случай: O(n log n)
- Худший случай: O(n²) — когда массив уже отсортирован или опорный элемент всегда минимальный/максимальный

**Пространственная сложность:**
- O(log n) — из-за рекурсивных вызовов

---

**Объяснение временной сложности:**
Временная сложность зависит от выбора опорного элемента:
- В лучшем случае: каждый раз массив делится пополам, создавая log₂ n уровней рекурсии, на каждом уровне выполняется O(n) операций
- В среднем случае: математическое ожидание дает O(n log n)
- В худшем случае: когда массив уже отсортирован и выбирается последний элемент, разделение происходит на массивы размером n-1 и 0, что приводит к O(n²)
- Эффективность можно улучшить выбором случайного опорного элемента или медианы

---

**Результат работы в IDE:**

Исходный массив:
10 7 8 9 1 5

Отсортированный массив:
1 5 7 8 9 10

---

**Примечание:**
Быстрая сортировка является одним из самых эффективных алгоритмов сортировки на практике. Основные преимущества: сортировка "на месте" (требует O(log n) дополнительной памяти), в среднем случае очень быстрая. Недостаток: нестабильность и худший случай O(n²), который можно избежать правильным выбором опорного элемента.

---
**Анализ алгоритма: Пирамидальная сортировка (Heap Sort)**

---

**Определение:**
Пирамидальная сортировка — это алгоритм сортировки, который использует структуру данных "двоичная куча" (binary heap). Алгоритм строит max-heap из входного массива, затем последовательно извлекает максимальный элемент из кучи и помещает его в конец отсортированного массива.

---

**Анализ:**
- Алгоритм состоит из двух основных этапов:
  - Построение max-heap из исходного массива
  - Последовательное извлечение максимального элемента
- Функция heapify поддерживает свойство кучи для поддерева с корнем в заданном индексе
- При построении кучи обрабатываются только элементы с индексами от n/2-1 до 0
- На этапе извлечения максимальный элемент (корень) меняется местами с последним элементом
- После каждого обмена размер кучи уменьшается на 1
- Процесс повторяется до полной сортировки массива

---

**Временная сложность:**
- Лучший случай: O(n log n)
- Средний случай: O(n log n)
- Худший случай: O(n log n)

**Пространственная сложность:**
- O(1) — сортировка выполняется на месте

---

**Объяснение временной сложности:**
Временная сложность O(n log n) объясняется следующим:
- Построение кучи имеет сложность O(n)
- Каждая операция heapify имеет сложность O(log n)
- Операция heapify выполняется n-1 раз при извлечении элементов
- Общая сложность: O(n) + O(n log n) = O(n log n)
- Эта сложность сохраняется во всех случаях, так как структура кучи гарантирует логарифмическую высоту

---

**Результат работы в IDE:**

Исходный массив:
12 11 13 5 6 7

Отсортированный массив:
5 6 7 11 12 13

---

**Примечание:**
Пирамидальная сортировка является эффективным алгоритмом с гарантированной временной сложностью O(n log n) во всех случаях. Основные преимущества: сортировка на месте, стабильная производительность. Недостаток: нестабильность (не сохраняет порядок равных элементов) и более сложная реализация по сравнению с некоторыми другими алгоритмами.

---
Последовательный поиск (Linear Search)

Определение:
Последовательный поиск — это простейший алгоритм поиска, который последовательно проверяет каждый элемент массива до тех пор, пока не будет найден искомый элемент или не будет достигнут конец массива.

Анализ:
- Алгоритм начинает поиск с первого элемента массива
- Сравнивает текущий элемент с искомым значением
- Если значения совпадают, возвращается индекс элемента
- Если не совпадают, алгоритм переходит к следующему элементу
- Процесс повторяется до нахождения элемента или завершения массива

Временная сложность: O(n)

Объяснение временной сложности:
- В худшем случае алгоритм проверяет все n элементов массива
- В среднем случае проверяется n/2 элементов
- В лучшем случае элемент находится на первой позиции (1 проверка)
- Количество операций линейно зависит от размера массива n

Результат работы в IDE:

Исходный массив: [3, 5, 2, 7, 9, 1, 4]
Искомый элемент: 7

Элемент найден на позиции: 3

Исходный массив: [10, 25, 8, 15, 30, 42, 17]
Искомый элемент: 20

Элемент не найден

Исходный массив: [1, 2, 3, 4, 5, 6, 7]
Искомый элемент: 1

Элемент найден на позиции: 0

---
Бинарный поиск (Binary Search)

Определение:
Бинарный поиск — это алгоритм поиска элемента в отсортированном массиве, который многократно делит интервал поиска пополам и сравнивает средний элемент с искомым значением.

Анализ:
- Алгоритм работает только с отсортированными массивами
- На каждом шаге определяется средний элемент текущего интервала поиска
- Если средний элемент равен искомому, поиск завершается
- Если средний элемент больше искомого, поиск продолжается в левой половине
- Если средний элемент меньше искомого, поиск продолжается в правой половине
- Процесс повторяется до нахождения элемента или исчерпания интервала поиска

Временная сложность: O(log n)

Объяснение временной сложности:
- На каждой итерации размер интервала поиска уменьшается вдвое
- Максимальное количество итераций равно log₂(n)
- Временная сложность логарифмическая относительно размера массива
- Алгоритм значительно эффективнее линейного поиска для больших массивов

Результат работы в IDE:

Отсортированный массив: [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
Искомый элемент: 7

Элемент найден на позиции: 3

Отсортированный массив: [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
Искомый элемент: 15

Элемент не найден

Отсортированный массив: [5, 10, 15, 20, 25, 30, 35, 40, 45, 50]
Искомый элемент: 25

Элемент найден на позиции: 4

---
Интерполирующий поиск (Interpolation Search)

Определение:
Интерполирующий поиск — это алгоритм поиска в отсортированном массиве, который использует интерполяционную формулу для предсказания позиции искомого элемента на основе значений первого и последнего элементов текущего интервала поиска.

Анализ:
- Алгоритм работает только с отсортированными массивами
- Использует формулу интерполяции для вычисления предполагаемой позиции элемента
- На каждом шаге сравнивает элемент в вычисленной позиции с искомым значением
- Если элемент найден, поиск завершается
- Если искомый элемент меньше, поиск продолжается в левой части интервала
- Если искомый элемент больше, поиск продолжается в правой части интервала
- Процесс повторяется рекурсивно или итеративно

Временная сложность: 
- O(log log n) — при равномерном распределении элементов
- O(n) — в худшем случае при неравномерном распределении

Объяснение временной сложности:
- В лучшем случае алгоритм находит элемент за константное время
- При равномерном распределении данных количество сравнений уменьшается экспоненциально
- В худшем случае (сильно неравномерное распределение) алгоритм вырождается в линейный поиск
- Эффективность сильно зависит от равномерности распределения данных в массиве

Результат работы в IDE:

Отсортированный массив: [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
Искомый элемент: 50

Элемент найден на позиции: 4

Отсортированный массив: [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
Искомый элемент: 12

Элемент не найден

Отсортированный массив: [2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]
Искомый элемент: 256

Элемент найден на позиции: 7

---
Поиск Фибоначчи (Fibonacci Search)

Определение:
Поиск Фибоначчи — это алгоритм поиска в отсортированном массиве, который использует числа Фибоначчи для определения позиций сравнения. Алгоритм делит массив на части, пропорциональные числам Фибоначчи, что позволяет эффективно сужать область поиска.

Анализ:
- Алгоритм работает только с отсортированными массивами
- Использует последовательность чисел Фибоначчи для определения точек разделения
- На каждом шаге сравнивает элемент в вычисленной позиции с искомым значением
- Если элемент найден, поиск завершается
- Если искомый элемент меньше, поиск продолжается в левой части с меньшими числами Фибоначчи
- Если искомый элемент больше, поиск продолжается в правой части с уменьшенными числами Фибоначчи
- Процесс повторяется до нахождения элемента или исчерпания интервала поиска

Временная сложность: O(log n)

Объяснение временной сложности:
- Алгоритм делит массив на части с помощью чисел Фибоначчи
- На каждой итерации размер области поиска уменьшается примерно на 1/φ (золотое сечение)
- Количество сравнений пропорционально log₂(n) как и в бинарном поиске
- В среднем требует примерно на 4% больше сравнений, чем бинарный поиск
- Эффективность сравнима с бинарным поиском, но использует только сложение и вычитание

Результат работы в IDE:

Отсортированный массив: [10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100]
Искомый элемент: 85

Элемент найден на позиции: 8

Отсортированный массив: [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
Искомый элемент: 12

Элемент не найден

Отсортированный массив: [5, 15, 25, 35, 45, 55, 65, 75, 85, 95]
Искомый элемент: 25

Элемент найден на позиции: 2
